# Schema Definitions & Migrations (idea)

This section describes the data format for *schema messages*. Schema messages contain instructions for forming both a database schema and message format.

As an example, the *slothmail* schema is described in a sequence of *schema messages*, which are published by the slothmail authors on the slothmail log. (A slothmail client is then implementing this schema and allows end users to create *instance messages*, which contain the slothmail *instances* they send each other. A server reads users' slothmail *instance messages* and creates a materialized view of slothmail *instances*.)

## Creating a new schema

The `panda` command line application is used to register a new schema for the fictional *slothmail* application.

```bash
$ panda schema slothmail init --description "Send slothmail to your friends!"
üêº Registered slothmail schema at log 12
```

The *slothmail* schema's bamboo log was initialized in the local user's log number 12.

A couple of fields are added to the schema by reading from a migration definition:

```bash
$ panda schema slothmail migrate slothmail-001.yaml
Created fields
- subject<text>
- body<text>
- created<datetime>
- recipient<panda-profile>

üêº Published slothmail version 2
```

The *slothmail* application can now start publishing slothmail messages.

#### More possibilities
(comments from adz)

Every user can use the `panda` command line too to create new schema messages. For example the user with the public address `d4a1cb88...` creates a new schema of type `comment`:

```
$ panda schema init --file comment-001.toml
üêº Registered comment schema
```

The `comment-001.toml` file could look like this:

```toml
[meta]
name = "comment"
description = "Send comments to your friends!"
spec = 1

[fields.body]
type = "text"

[fields.created]
type = "timestamp"
```

... another way could be to use an client / web application which offers a nice wizard-like UI to manage a schema step by step.

The created message / bamboo entry payload could look like this. The message format is following the same specification as all other messages (including a `kind`, `schema` and `spec` field in the root):

```yml
kind: create
schema: schema
spec: 1 # this is the message spec version
fields:
  name: comment
  description: Send comments to your friends!
  spec: 1 # this is the schema spec version
  fields:
    - subject:
      type: text
    - body:
      type: text
    - created:
      type: timestamp
```

The client can send this message to the server where it will be stored in system log `0` of this user.

##### Register schema

To use this newly introduced schema the administrator can register it via command line:

```
panda schema register --name comment --address d4a1cb88a66f02f8db635ce26441cc5dac1b08420ceaac230839b755845a9ffb
üéç Now indexing comment messages
```

It would throw an error if it couldn't find any schemas of type `comment` from this address.

The server would check if an schema of type `comment` was already registered. In this case it would create a temporary new table and run the indexing mechanism, scanning all logs again to find messages of type `comment`.

Please note here that the server will ignore all messages of type `comment` which do not follow the schema. This puts an extra responsibility on the creator of the schema and the administrator to not mess too much with breaking conventions. In case something important has to be changed a) clients have to be updated to support that change or b) a new name has to be introduced.

Schemes which refer to other schemes (relations), can be registered but are only indexed when all schemes are registered. The server would register the schema and put them in some sort of waiting queue for indexing until all requirements are fulfilled.

##### Namespace / Version conflicts

We can imagine another user creating a scheme with the same name `comment`. The server admin addresses which schema is meant by refering to the creators public address. For the client this distinction is not being made which puts a responsibility and community effort to maintain a common understanding on what names are used (similar to SSB and ActivityPub).

This is a tradeoff to allow for simpler GraphQL queries automatically generated by services like Postgraphile, otherwise we would need to add to every query which schema we refer to and propably build our own GraphQL resolver.

```
comments {
  body
  created
}

vs.

comments(schemaAddress: "d4a1cb88a66f02f8db635ce26441cc5dac1b08420ceaac230839b755845a9ffb", schemaVersion: 2) {
  body
  created
}
```

## Materializing a new schema on a server

All p2panda servers make available their user's log entries to each other. In addition to that, they can offer materialized views of some of the data contained in those logs. For this, server administrators instruct the server to index messages of a certain schema.

Here, the *slothmail* schema is indexed. It is referred to by the public key of the schema's author and the log id in which that author published the schema.

```bash
$ beep-beep-server index 88e1cb88a66f02f8db635ce26441cc5dac1b08420ceaac230839b755845a9ffb 12
üéç Now indexing slothmail messages
```

## Initial Schema instantiation

When indexing a schema, a server executes all migrations in the schema‚Äôs log in order to create a database table capable of holding instances of the schema at its latest known version. Now, all known *instance messages* can be inserted into the database, which results in the database contents representing a view of all known instances at their latest versions.

Migrations can also be applied to messages in order to make them compatible with the current schema version. When an incoming message specifies a schema version older than the latest known schema version, all intermittent migrations are applied to this message so that it can be applied to the database. When a message specifies a schema version that is not known, the server tries to request that schema version‚Äôs entry using bamboo.

## Schema migration messages

A schema describes a database schema and a message specification through a series of schema migrations. A schema is represented by a bamboo log. Every message on the log is a schema migration. Thereby, the version number of a schema migration is the *sequence number* of the migration's log entry.

Each schema migration is one of:

- `schema-meta`: sets schema metadata
- `schema-migration`: Used by server to create or alter database tables and to migrate *instance messages*.
- `schema-revert`: Used by server to revert to an earlier version, recreating instance data, which may have been deleted or corrupted by intermittent migrations.

Schema migrations are encoded using a subset of [CDDL](https://tools.ietf.org/html/rfc8610#page-5). Examples in this draft are encoded in YAML.

### Meta schema message

A meta schema message describes the schema itself. It contains following fields. Only those marked with an X in the "Required" column are required.

| Field name | Description | Required |
| --- | --- | --- |
| name | Name of the schema | X |
| spec | Which verison of this schema meta-spec is implemented | X |
| description | Description of the schema's purpose | |
| homepage | URL pointing at a web site for the schema | |
| license | A comma-separated list of licenses that apply for the schema definition | |
| contact | An email-address for contacting the schema's authors | |

#### Examples

Minimal meta schema message for a fictional messaging format *slothmail*.

```yaml
kind: schema-meta
name: slothmail
spec: 1
```

Example using all available fields

```yaml
kind: schema-meta
name: slothmail
spec: 1
description: Send slothmail to your friends!
homepage: https://liebechaos.org/activity/slothmail
license: CC-BY-SA 2.0 <https://creativecommons.org/licenses/by-sa/2.0/>
contact: info@liebechaos.org
```

### Migrate schema message

A migrate schema message creates or alters the schema‚Äôs table and updates its rows. A migration describes changes to one or more fields. If no database table exists for the schema, a new database table is created when applying the message. Server implementations should consider that schema names are non-unique when constructing table names.

Fields may be created, updated or removed. For each created or updated field, a new data type is specified. For updated fields, a default value must be specified that is stored if conversion to the new data type fails. Each field is described by its

- action (`create`, `update`, or `remove`)
- name (unicode string)
- type (see below)
- validation (optional regex pattern)

Type must be one of:

- `varchar` (max 255 chars)
- `text`
- `integer`
- `float`
- `boolean`
- `timestamp` (ISO-8601 timestamp)
- `relation`

Every type may also be specified as an array by adding `[]` behind the type name.

A `relation` type also specifies the `versioned-schema` of its foreign key. A `relation` type may specify `cascade: true` in which case schema instances are deleted once the foreign key is deleted.

The field `validation` may contain a regular expression used to validate messages of this schema.

If a `schema-migration` message removes the last of a schema‚Äôs fields, the schema‚Äôs database table may be dropped.

#### Examples

Example to create the *slothmail* schema

```yaml
kind: schema-migration
fields:
  - subject:
    action: create
    type: text
  - body:
    action: create
    type: text
  - recipient:
    action: create
    type: relation
    schema:
      # author for the schema of the recipient field
      - d4a1cb88a66f02f8db635ce26441cc5dac1b08420ceaac230839b755845a9ffb
      # schema's log id
      - 10
      # relation is schema-version agnostic
  - created:
    action: create
    type: timestamp
```

Example to add an attachments field to the slothmail schema:

```yaml
kind: schema-migration
fields:
  - attachments:
    action: create
    type: relation[]
    schema:
      - ac1b08420ceaac230839b755845a9ffbd4a1cb88a66f02f8db635ce26441cc5d
      - 78434
```

Example to remove the attachments field and change the subject to not contain line breaks

```yaml
kind: schema-migration
fields:
  - attachments
    action: remove
  - subject
    action: update
    validation: ^[^#\r\n].*$
    default: <Subject>
```
### Revert schema message

A revert schema message reverts previous migrations and resets the database to a previous schema version (`target`). This is desirable instead of reverting by altering fields in order to restore data deleted by previous migrations.

The database is recreated by dropping the database and reapplying all known instance messages and all migrations up to the target migration. `create` and `update` instance messages, which specify a schema version later than the target version are ignored. `delete` instance messages are applied regardless of the version mismatch in order to prevent schema authors from restoring user data against their will.

#### Examples

The previous example removed the `attachments` field. During migration all slothmail attachments were deleted from slothmail instances. Simply adding the field back would not recover the deleted attachments. Here, the schema is reverted to a previous version that still had the `attachments` field, which recreates all the attachments by re-indexing all slothmail instances.

```yaml
kind: schema-revert
target: 2
```
